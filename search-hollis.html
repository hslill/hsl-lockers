<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search Transactions</title>
    <link rel="stylesheet" href="css/styles-main.css">
    <link rel="stylesheet" href="css/mobile-search.css"
    <!-- Add Tablesort library -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tablesort/5.2.1/tablesort.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.34/moment-timezone-with-data.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>

    <div id="edit-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Edit Record</h2>

            <input type="text" id="edit-transaction" placeholder="Transaction Number">
            <input type="text" id="edit-barcode" placeholder="Barcode URL">
    
            <label for="edit-locker">Locker #:</label>
            <input type="text" id="edit-locker" readonly>
    
            <label for="edit-book">Book Details:</label>
            <textarea id="edit-book" rows="4" style="resize: both; overflow: auto;"></textarea>         
    
            <label for="edit-email">Recipient Email:</label>
            <input type="text" id="edit-email">
    
            <label for="edit-name">Recipient Name:</label>
            <input type="text" id="edit-name">
    
            <!-- Notify recipient checkbox -->
            <label for="notifyRecipientCheckbox">
                <input type="checkbox" id="notifyRecipientCheckbox"> Notify recipient by email
            </label>
            <input style="display: none;" class="textarea" id="notificationForm">
    
            <button id="save-edit">Save Changes</button>
        </div>
    </div>
    

        <div class="logoutButton">
          <!-- Content for logged-in users -->
          <div id="content">
            <button id="logout-button">Logout</button>
          </div>
        </div>
    </head>
        <body id="search-page">
            <header>
                <h1>Search Transactions</h1>
            </header>
            <main>
                <section id="search-section">
                    <input type="text" id="search-input" placeholder="Press ENTER for all, or enter details to filter" />
                    <label for="start-date">Start Date:</label>
                    <input type="date" id="start-date" />
                    <label for="end-date">End Date:</label>
                    <input type="date" id="end-date" />
                    <button id="search-button">Search</button>
        
                    <!-- Filter checkbox for canceled requests -->
                    <label>
                        <input type="checkbox" id="show-canceled"> Show only canceled requests
                    </label>
                    <br>
                    <!-- Filter checkboxes for locker groups -->
                    <p style="font-weight: bold;"> Filter by library:</p>
                    <label>
                        <input type="checkbox" id="locker-group-1"> Lapidus Lockers # 1-31
                    </label>
                    <label>
                        <input type="checkbox" id="locker-group-2"> Robbins Lockers # 32-39
                    </label>
                    <label>
                        <input type="checkbox" id="locker-group-3"> Hollis Lockers # 40-48
                    </label>                    
                </p>
                </section>
                
                <section id="results-section">
                    <table id="results-table" class="display">
                        <thead>
                            <tr>
                                <th>Locker #</th>
                                <th>Transaction Number</th>
                                <th>Date Received</th>
                                <th>Date Picked Up</th>
                                <th>Date Canceled</th>
                                <th>Book Details</th>
                                <th>Recipient Email</th>
                                <th>Recipient</th>
                                <th>Locker Status</th>
                                <th>Actions</th> <!-- Added column for cancel buttons -->
                            </tr>
                        </thead>               
                        <tbody>
                            <!-- Results will be dynamically inserted here -->
                        </tbody>
                    </table>
        
                    <!-- Row for displaying results count -->
                    <div id="results-count">
                        <p>Total Results Found: <span id="total-results">0</span></p>
                    </div>
                </section>
        
                <div id="buttonContainer">
                    <!-- Buttons for exporting CSV, PDF, and Print -->
                    <div id="export-buttons">
                      <button id="export-csv" class="btn">
                        <i class="fas fa-file-csv"></i> Export
                      </button>
                      <button id="export-pdf" class="btn">
                        <i class="fas fa-file-pdf"></i> Download
                      </button>
                      <button id="print-results" class="btn">
                        <i class="fas fa-print"></i> Print
                      </button>
                    </div>
                  
                    <!-- New container for Reset and Home -->
                    <div id="reset-home-buttons">
                      <input
                        type="button"
                        id="resetSearchButton"
                        name="Reset"
                        value="Reset"
                      />
                      <a id="homeLink" href="index-hollis.html" class="btn">Home</a>
                    </div>
                  </div>  
            </main>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.0/firebase-app.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.6.0/firebase-storage.js";
        import { getFirestore, collection, getDocs, doc, setDoc, getDoc, updateDoc, query, where } from "https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore.js";
        import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.6.0/firebase-auth.js"; // Import Firebase Auth
        // Initialize EmailJS
emailjs.init("qyLLqnBmF7BYPrdLZ");
        const firebaseConfig = {
            apiKey: "AIzaSyC17BbuCs63DFzBdxnFFeO-Ejv1WECS7-E",
            authDomain: "book-pickup-kiosk01.firebaseapp.com",
            projectId: "book-pickup-kiosk01",
            storageBucket: "book-pickup-kiosk01.firebasestorage.app",
            messagingSenderId: "77991134959",
            appId: "1:77991134959:web:28dde2b643a22bed6abd1a"
        };
    
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app); // Initialize Firebase Auth

                // Check authentication status
                onAuthStateChanged(auth, user => {
            if (!user) {
                // If the user is not authenticated, redirect to login page (index-hollis.html)
                window.location.href = 'index-hollis.html';
            } else {
                // User is authenticated, proceed with loading the page
                console.log("User is authenticated:", user.email);
            }
        });

        async function searchTransactions(queryText) {
    try {
        console.log("Searching for:", queryText);

        const resultsTable = document.getElementById("results-table").getElementsByTagName("tbody")[0];
        resultsTable.innerHTML = ""; // Clear previous results
        document.getElementById("total-results").innerText = "0"; // Reset the results count

        const startDate = document.getElementById("start-date").value;
        const endDate = document.getElementById("end-date").value;
        const includeCanceled = document.getElementById("show-canceled").checked; // Get the checkbox value

        function formatDate(rawDate) {
            const [date, timeWithTimezone] = rawDate.split('T');
            const [time, timezone] = timeWithTimezone.split(/(?<=\d)(?=[A-Za-z])/);

            const [year, month, day] = date.split('-');
            const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const monthName = months[parseInt(month, 10) - 1];
            const formattedDate = `${monthName} ${day} ${year}`;
            const timeWithoutSeconds = time.slice(0, 5);
            return `${formattedDate}, ${timeWithoutSeconds} ${timezone}`;
        }

        const transactionsRef = collection(db, "transactions");
        const transactionsSnapshot = await getDocs(transactionsRef);

        const lockersRef = collection(db, "lockers");
        const lockerSnapshot = await getDocs(lockersRef);

        // Map locker numbers to their statuses for easy lookup
        const lockerStatusMap = {};
        lockerSnapshot.forEach((doc) => {
            const data = doc.data();
            lockerStatusMap[doc.id] = data.status === "in-use" ? "In Use" : "Available";
        });

        console.log("Locker Status Map:", lockerStatusMap);  // Debugging: Check the locker status map

        let resultsFound = 0; // Track the number of results found

        transactionsSnapshot.forEach((doc) => {
    const data = doc.data();
    const dateReceived = (typeof data.dateReceived === 'string') ? data.dateReceived.split('T')[0] : null;
    const datePickedup = (typeof data.datePickedup === 'string') ? data.datePickedup.split('T')[0] : null;
    const dateCanceled = (typeof data.dateCanceled === 'string') ? data.dateCanceled.split('T')[0] : null;

    if ((startDate && dateReceived && dateReceived < startDate) ||
        (endDate && dateReceived && dateReceived > endDate)) {
        return;
    }

    const fieldsToSearch = [
        data.bookDetails,
        data.recipientEmail,
        data.recipientName,
        doc.id
    ];

    const matchesQuery = queryText.trim() === "" || 
    fieldsToSearch.some(field => typeof field === 'string' && field.toLowerCase().includes(queryText.toLowerCase()));

if (!includeCanceled) {
    if (matchesQuery) {
        resultsFound++;
        const row = resultsTable.insertRow();

        const lockerStatusKey = `locker_${data.lockerNumber}`;
        const lockerStatus = lockerStatusMap[lockerStatusKey] || "Unknown";

        // Check if Date Picked Up or Date Canceled is populated and hide cancel button accordingly
        const cancelButton = (datePickedup || dateCanceled) ? '' : `<button class="cancel-btn" data-doc-id="${doc.id}">Cancel</button>`;

        row.innerHTML = `
            <td><input type="checkbox" class="select-checkbox"></td>  <!-- ✅ Checkbox added here -->
            <td>${data.lockerNumber}</td>
            <td>${doc.id}</td>
            <td>${dateReceived ? formatDate(data.dateReceived) : "N/A"}</td>
            <td>${datePickedup ? formatDate(data.datePickedup) : "N/A"}</td>
            <td>${dateCanceled ? formatDate(data.dateCanceled) : "N/A"}</td>
            <td>${data.bookDetails || "N/A"}</td>
            <td>${data.recipientEmail || "N/A"}</td>
            <td>${data.recipientName || "N/A"}</td>
            <td>${lockerStatus}</td>
            <td>${cancelButton}</td>
            <td><button class="edit-btn" data-doc-id="${doc.id}" data-locker="${data.lockerNumber}" data-book="${data.bookDetails}" 
        data-email="${data.recipientEmail}" data-name="${data.recipientName}" data-transaction-number="${data.transactionNumber}">Edit</button></td>
        `;
    }
} else {
    if (matchesQuery && dateCanceled) {
        resultsFound++;
        const row = resultsTable.insertRow();

        const lockerStatusKey = `locker_${data.lockerNumber}`;
        const lockerStatus = lockerStatusMap[lockerStatusKey] || "Unknown";

        // Check if Date Picked Up or Date Canceled is populated and hide cancel button accordingly
        const cancelButton = (datePickedup || dateCanceled) ? '' : `<button class="cancel-btn" data-doc-id="${doc.id}">Cancel</button>`;

        row.innerHTML = `
            <td><input type="checkbox" class="select-checkbox"></td>  <!-- ✅ Checkbox added here -->
            <td>${data.lockerNumber}</td>
            <td>${doc.id}</td>
            <td>${dateReceived ? formatDate(data.dateReceived) : "N/A"}</td>
            <td>${datePickedup ? formatDate(data.datePickedup) : "N/A"}</td>
            <td>${dateCanceled ? formatDate(data.dateCanceled) : "N/A"}</td>
            <td>${data.bookDetails || "N/A"}</td>
            <td>${data.recipientEmail || "N/A"}</td>
            <td>${data.recipientName || "N/A"}</td>
            <td>${lockerStatus}</td>
            <td>${cancelButton}</td>
            <td><button class="edit-btn" data-doc-id="${doc.id}" data-locker="${data.lockerNumber}" data-book="${data.bookDetails}" 
        data-email="${data.recipientEmail}" data-name="${data.recipientName}" data-transaction-number="${data.transactionNumber}">Edit</button></td>
        `;
    }
}

});

        // If no results were found in collections
        if (resultsFound === 0) {
            alert(`No results found for the entered search term: "${queryText}"`);
        }

        // Update the results count
        document.getElementById("total-results").innerText = resultsFound;

// Initialize Tablesort
const table = document.getElementById("results-table");
if (table) {
    // Initialize Tablesort but exclude the "Select" column from being sortable
    const tablesort = new Tablesort(table, {
        // Sort options: define which columns are sortable
        column: (th) => th.cellIndex !== 0 // Exclude the "Select" column (index 0)
    });

    // Add sortable class to headers for CSS styling (skip "Select" column)
    const headers = table.querySelectorAll("th");
    headers.forEach((header, index) => {
        if (index !== 0) { // Skip the "Select" column (index 0)
            header.classList.add("sortable");
        }
    });

    // Add event listener for sort event
    table.addEventListener("sort", function (e) {
        console.log(e.detail);  // Log the e.detail object in the sort event

        if (e.detail && e.detail.direction) {  // Check if e.detail and e.detail.direction are available
            const th = e.target;
            const isAsc = e.detail.direction === "asc";
            headers.forEach(header => header.classList.remove("asc", "desc"));
            th.classList.add(isAsc ? "asc" : "desc");
        } else {
            console.error("Sorting direction is not available in e.detail.");
        }
    });
}

        // Add event listener to cancel buttons
        const cancelBtns = document.querySelectorAll(".cancel-btn");
        cancelBtns.forEach(button => {
            button.addEventListener("click", cancelRequest); // Assigning cancelRequest function here
        });

    } catch (error) {
        console.error("Error fetching transactions:", error);
    }
}

// The cancelRequest function to update the transaction as canceled
function cancelRequest(event) {
    const transactionId = event.target.getAttribute("data-doc-id");

    // Get the current time formatted in EDT
    const now = moment().tz("America/New_York");  // Get current time in EDT
    const formattedDate = now.format("YYYY-MM-DDThh:mm:ssA-") + now.format("z");  // Format as '2025-01-29T09:51:16PM-EST'

    // Mark the transaction as canceled with the formatted date
    const transactionRef = doc(db, "transactions", transactionId);
    updateDoc(transactionRef, {
        dateCanceled: formattedDate // Use the formatted date for cancellation
    }).then(() => {
        console.log("Transaction canceled:", transactionId);
        searchTransactions(""); // Refresh the results after canceling
    }).catch((error) => {
        console.error("Error canceling transaction:", error);
    });
}

// Event listener for DOMContentLoaded
document.addEventListener("DOMContentLoaded", function () {
    console.log("Search page loaded.");
});

document.getElementById("search-button").addEventListener("click", () => {
    const searchText = document.getElementById("search-input").value;
    searchTransactions(searchText);
});
        document.getElementById("search-button").addEventListener("keydown", (event) => {
    if (event.key === "Enter" || event.key === " ") {  // Check for Enter or Space
        event.preventDefault();  // Prevent unintended scrolling
        document.getElementById("search-button").click();  // Trigger the search
    }
});

let initialSearchPerformed = false;

// Listen for the initial search
document.getElementById("search-button").addEventListener("click", () => {
    initialSearchPerformed = true; // Set flag when initial search is performed
});

// Listen for checkbox changes to trigger search
document.getElementById("show-canceled").addEventListener("click", () => {
    if (initialSearchPerformed) {
        const searchText = document.getElementById("search-input").value;
        searchTransactions(searchText);
    }
});

document.getElementById("locker-group-1").addEventListener("click", applyLockerFilter);
document.getElementById("locker-group-2").addEventListener("click", applyLockerFilter);
document.getElementById("locker-group-3").addEventListener("click", applyLockerFilter);

function applyLockerFilter() {
    const showGroup1 = document.getElementById("locker-group-1").checked;
    const showGroup2 = document.getElementById("locker-group-2").checked;
    const showGroup3 = document.getElementById("locker-group-3").checked;

    const tableRows = document.querySelectorAll("#results-table tbody tr");

    tableRows.forEach(row => {
        const lockerCell = row.cells[1]; // The second column (index 1) contains "Locker #"
        if (!lockerCell) return; // Skip if no cell found

        const lockerNumber = parseInt(lockerCell.textContent.trim(), 10);

        // Check if the locker belongs to one of the selected groups
        const inGroup1 = lockerNumber >= 1 && lockerNumber <= 31;
        const inGroup2 = lockerNumber >= 32 && lockerNumber <= 39;
        const inGroup3 = lockerNumber >= 40 && lockerNumber <= 48;

        if (
            (showGroup1 && inGroup1) ||
            (showGroup2 && inGroup2) ||
            (showGroup3 && inGroup3) ||
            (!showGroup1 && !showGroup2 && !showGroup3) // Show all if none selected
        ) {
            row.style.display = "";
        } else {
            row.style.display = "none";
        }
    });
}

// Reset search form functionality
document.getElementById("resetSearchButton").addEventListener("click", function () {
    document.getElementById("search-input").value = "";
    document.getElementById("start-date").value = "";
    document.getElementById("end-date").value = "";
    document.getElementById("show-canceled").checked = false;
    document.getElementById("locker-group-1").checked = false;
    document.getElementById("locker-group-2").checked = false;
    document.getElementById("locker-group-3").checked = false;
    searchTransactions(""); // Clear search results
});


        // Add keyboard accessibility
        document.getElementById("search-button").addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
                event.preventDefault(); // Prevent default behavior for space key
                const queryText = document.getElementById("search-input").value.trim();
                if (queryText) {
                    searchTransactions(queryText);
                } else {
                    return;
                }
            }
        });

        // Attach the event listener to the button
        const resetSearchButton = document.getElementById("resetSearchButton");
        resetSearchButton.addEventListener("click", () => {
            // Reload the page to reset the search
            window.location.reload();
        });

        document.addEventListener("DOMContentLoaded", () => {
    const homeLink = document.getElementById("homeLink");
    if (homeLink) {
        homeLink.addEventListener("click", (event) => {
            event.preventDefault();
            window.location.href = "index-hollis.html";
        });
    }
});

        // Shift rows to the right for export purposes
function shiftRowsToRightForExport() {
    const table = document.getElementById("results-table");
    const rows = table.querySelectorAll("tr");

    rows.forEach((row, index) => {
        const cells = row.querySelectorAll("td, th");
        if (cells.length > 0) {
            // Remove the first cell in each row (the "Select" column)
            row.deleteCell(0);
        }
    });
}

// Export to CSV (Visible Rows Only)
function exportToCSV() {
    shiftRowsToRightForExport(); // Fix: call function to shift rows

    const table = document.getElementById("results-table");
    const headers = table.querySelectorAll("thead th");
    const rows = table.querySelectorAll("tbody tr");

    // Extract headers
    const headerData = [];
    headers.forEach(header => {
        headerData.push(header.textContent.trim());
    });

    const data = [headerData]; // Start the data array with headers

    // Extract row data, only for visible rows
    rows.forEach(row => {
        if (row.style.display !== "none") {  // Only include visible rows
            const rowData = [];
            row.querySelectorAll("td").forEach(cell => {
                rowData.push(cell.textContent.trim());
            });
            data.push(rowData);
        }
    });

    // Use PapaParse to convert data to CSV and download
    const csv = Papa.unparse(data);
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'search_results.csv';
    link.click();

    restoreRowsAfterExport(); // Fix: call function to restore rows after export
}

// Export to PDF (Visible Rows Only)
function exportToPDF() {
    shiftRowsToRightForExport(); // Fix: call function to shift rows

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'mm', 'letter');  // Set portrait orientation (p), millimeters as units (mm), letter size
    
    const table = document.getElementById("results-table");
    const rows = table.querySelectorAll("tbody tr");
    
    let y = 20;  // Start below the top margin
    const pageWidth = doc.internal.pageSize.width;
    const pageHeight = doc.internal.pageSize.height;

    // Define margins with narrower left and right margins
    const marginLeft = 10;   // Narrow left margin
    const marginRight = 10;  // Narrow right margin
    const marginTop = 20;   // Top margin
    const marginBottom = 20;  // Bottom margin
    
    // Set font size to default (approx 10px)
    doc.setFontSize(10);

    // Function to wrap text and prevent overflow
    function wrapText(text, maxWidth) {
        return doc.splitTextToSize(text, maxWidth);
    }

    // Loop through each row in the table and format the output, only visible rows
    rows.forEach(row => {
        if (row.style.display !== "none") {  // Only process visible rows
            const rowData = {};
            row.querySelectorAll("td").forEach((cell, index) => {
                const header = [
                    "Locker #", 
                    "Transaction Number", 
                    "Date Received", 
                    "Date Picked Up",
                    "Date Canceled",
                    "Book Details", 
                    "Recipient Email", 
                    "Recipient", 
                    "Locker Status"
                ][index]; // Define the headers based on the order in the table
                rowData[header] = cell.textContent.trim(); // Store the data under its header
            });

            // Create each 'table' by printing each key-value pair
            Object.keys(rowData).forEach((header, i) => {
                const lineText = `${header} | ${rowData[header]}`;
                const wrappedLine = wrapText(lineText, pageWidth - marginLeft - marginRight);
                doc.text(wrappedLine, marginLeft, y);  // Apply left margin
                y += wrappedLine.length * 2 + 5; // Space between rows
                
                // If the current section is "Book Details", add an extra space before the next section
                if (header === "Book Details") {
                    y += 5; // Add extra space before printing "Recipient Email"
                }
                
                // Check if the content exceeds the page height, and create a new page if necessary
                if (y > pageHeight - marginBottom) {
                    doc.addPage();
                    y = marginTop;  // Reset the y position after page break
                }
            });

            // Add some space between "tables"
            y += 10;
        }
    });

    // Save PDF
    doc.save('search_results.pdf');

    restoreRowsAfterExport(); // Fix: call function to restore rows after export
}

// Print Only Visible Rows
function printTable () {
    shiftRowsToRightForExport(); // Fix: call function to shift rows

    const table = document.getElementById("results-table");
    const rows = table.querySelectorAll("tbody tr");

    // Create a temporary table to hold only visible rows
    const printTable = document.createElement("table");

    // Copy headers to the print table
    const headers = table.querySelector("thead").cloneNode(true);
    printTable.appendChild(headers);

    // Loop through each row and only add visible rows to the print table
    rows.forEach(row => {
        if (row.style.display !== "none") {  // Only include visible rows
            const clonedRow = row.cloneNode(true);
            printTable.appendChild(clonedRow);
        }
    });

    // Open the print window and print the table
    const printWindow = window.open('', '', 'height=600,width=800');
    printWindow.document.write('<html><head><title>Print Table</title></head><body>');
    printWindow.document.write(printTable.outerHTML);
    printWindow.document.write('</body></html>');
    printWindow.document.close();
    printWindow.print();

    restoreRowsAfterExport(); // Fix: call function to restore rows after export
}


// Restore rows after export
function restoreRowsAfterExport() {
    const table = document.getElementById("results-table");
    const rows = table.querySelectorAll("tr");

    rows.forEach((row, index) => {
        const cells = row.querySelectorAll("td, th");
        if (cells.length === 0) return; // Skip header row

        const firstCell = document.createElement(index === 0 ? 'th' : 'td'); // For header, create <th> otherwise <td>
        firstCell.textContent = "";  // Leave the first cell blank (or add content as needed)
        row.insertBefore(firstCell, row.firstChild); // Insert the empty cell at the beginning of the row
    });
}

document.getElementById("export-csv").addEventListener("click", exportToCSV);
document.getElementById("export-pdf").addEventListener("click", exportToPDF);
document.getElementById("print-results").addEventListener("click", printTable);

// Handle logout
document.getElementById('logout-button').addEventListener('click', async () => {
    try {
        await signOut(auth);
        document.getElementById('content').style.display = 'none';
    } catch (error) {
        console.error("Error logging out:", error.message);
    }
});

document.addEventListener("DOMContentLoaded", () => {
    const modal = document.getElementById("edit-modal");
    const closeModal = document.querySelector(".close");
    const saveEditBtn = document.getElementById("save-edit");
    const transactionInput = document.getElementById("edit-transaction");
    const barcodeInput = document.getElementById("edit-barcode");

    let currentDocId = null; // Store document ID being edited

    // Function to generate barcode URL dynamically
    function generateBarcode(transactionNumber) {
        if (!transactionNumber) {
        // If the transaction number is somehow missing or undefined, return a fallback URL or handle the error case
        console.error("Transaction number is missing");
        return "fallback-barcode-url";  // or handle appropriately
        }

        return `https://bwipjs-api.metafloor.com/?bcid=code128&text=${encodeURIComponent(transactionNumber)}&scale=3&height=10`;
    }

    // Update barcode field whenever transaction number changes
    transactionInput.addEventListener("input", () => {
        const transactionNumber = transactionInput.value.trim();
        const barcodeUrl = generateBarcode(transactionNumber);
        barcodeInput.value = barcodeUrl; // Update hidden input with barcode URL
    });

    // Open modal when Edit button is clicked
    document.addEventListener("click", (event) => {
        if (event.target.classList.contains("edit-btn")) {
            const btn = event.target;
            currentDocId = btn.dataset.docId; 

            document.getElementById("edit-locker").value = btn.dataset.locker;
            document.getElementById("edit-book").value = btn.dataset.book;
            document.getElementById("edit-email").value = btn.dataset.email;
            document.getElementById("edit-name").value = btn.dataset.name;

            // Populate the transaction number (edit-transaction) field
            const transactionNumber = btn.dataset.transactionNumber;  // Assuming transaction number is in data-transaction-number
            document.getElementById("edit-transaction").value = transactionNumber;
            document.getElementById("edit-barcode").value = generateBarcode(transactionNumber);

            modal.style.display = "block";
        }
    });

    // Close modal
    closeModal.addEventListener("click", () => {
        modal.style.display = "none";
    });

// Save changes to Firestore
saveEditBtn.addEventListener("click", async () => {
    if (currentDocId) {
        const updatedData = {
            transactionNumber: document.getElementById("edit-transaction").value,
            barcodeUrl: document.getElementById("edit-barcode").value,
            bookDetails: document.getElementById("edit-book").value,
            recipientEmail: document.getElementById("edit-email").value,
            recipientName: document.getElementById("edit-name").value
        };

        try {
            // Get the locker number from the modal
            let lockerNumber = document.getElementById("edit-locker").value;

            // Remove 'locker_' prefix ONLY for the 'transactions' collection
            const lockerNumberForTransaction = lockerNumber.startsWith('locker_') ? lockerNumber.replace('locker_', '') : lockerNumber;

            // Reference the 'transactions' collection and update it
            const docRef = doc(db, "transactions", currentDocId);
            await updateDoc(docRef, {
                ...updatedData,
                lockerNumber: lockerNumberForTransaction // Save only the locker number (without 'locker_' prefix)
            });

            // Reference the 'lockers' collection and update the locker information
            const lockerRef = doc(db, "lockers", `locker_${lockerNumber}`); // Keep the 'locker_' prefix for the lockers collection
            await updateDoc(lockerRef, {
                bookDetails: document.getElementById("edit-book").value  // Update bookDetails in the lockers collection
            });

            alert("Record and locker updated successfully!");
            modal.style.display = "none";
            searchTransactions(""); // Refresh table

        } catch (error) {
            console.error("Error updating record:", error);
            alert("Failed to update record.");
        }
    }
});


    // Close modal when clicking outside
    window.addEventListener("click", (event) => {
        if (event.target === modal) {
            modal.style.display = "none";
        }
    });

    // Event listener for Save Changes button
    saveEditBtn.addEventListener('click', function () {
        // Get values from input fields
        const recipientName = document.getElementById('edit-name').value.trim();
        const recipientEmail = document.getElementById('edit-email').value.trim();
        const bookDetails = document.getElementById('edit-book').value.trim();
        const lockerNumber = document.getElementById('edit-locker').value.trim();

        // Ensure all necessary fields are filled before sending email
        if (!recipientName || !recipientEmail || !bookDetails || !lockerNumber) {
            console.error("Missing required fields. Email will not be sent.");
            return;
        }

        console.log("Save button clicked. Sending email if checkbox is checked...");
        sendEmail(recipientName, recipientEmail, bookDetails, lockerNumber);
    });
});


// Function to send email
function sendEmail(recipientName, recipientEmail, bookDetails, lockerNumber) {
    const notifyRecipientCheckbox = document.getElementById('notifyRecipientCheckbox');
    
    if (!notifyRecipientCheckbox) {
        console.error("notifyRecipientCheckbox not found.");
        return;
    }

    if (!notifyRecipientCheckbox.checked) {
        console.log("Checkbox is not checked. Email won't be sent.");
        return;
    }

    // Retrieve transaction number and barcode URL from input fields
    const transactionNumber = document.getElementById("edit-transaction").value.trim();
    const barcodeUrl = document.getElementById("edit-barcode").value.trim();

    if (!transactionNumber || !barcodeUrl) {
        console.error("Missing transaction number or barcode URL. Email will not be sent.");
        return;
    }

    const emailData = {
        recipientName,
        recipientEmail,
        bookDetails,
        lockerNumber,
        transactionNumberField: transactionNumber, // Matches EmailJS template
        barcode_url: barcodeUrl  // Matches EmailJS template
    };

    console.log("Sending email with data:", emailData);

    emailjs.send("pickup", "book_pickup_robbins", emailData)
        .then((response) => {
            console.log('Email sent successfully!', response);
            alert('Email sent successfully!');
        })
        .catch((error) => {
            console.error('Failed to send email:', error);
            alert('Failed to send email!');
        });
}

let hiddenRows = []; // Array to store hidden rows

function addSelectColumn() {
    const table = document.getElementById("results-table");
    const thead = table.querySelector("thead");
    const tbody = table.querySelector("tbody");

    // Create a new row for the Select All checkbox
    const selectAllRow = document.createElement("tr");
    const selectAllHeader = document.createElement("th");
    selectAllHeader.setAttribute("colspan", "1"); // Ensure the checkbox is in a single cell

    // Create "Select All" checkbox and append it inside the new row
    const selectAllCheckbox = document.createElement("input");
    selectAllCheckbox.type = "checkbox";
    selectAllCheckbox.id = "select-all-checkbox";
    selectAllHeader.appendChild(selectAllCheckbox);

    // Append the new row above the original header row
    selectAllRow.appendChild(selectAllHeader);
    thead.prepend(selectAllRow);  // Add the new row as the first row

    // Create "Select" column header
    const selectHeader = document.createElement("th");
    selectHeader.textContent = "Select";
    selectHeader.setAttribute("data-sorter", "false"); // Disable sorting for "Select" column
    selectHeader.classList.add("no-hover");
    // Add the "Select" header to the original header row
    const originalHeaderRow = thead.querySelector("tr:nth-child(2)");  // Select the second row
    originalHeaderRow.prepend(selectHeader);

    // Add checkboxes to each row in the body
    Array.from(tbody.rows).forEach(row => {
        const cell = document.createElement("td");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.classList.add("select-checkbox");
        cell.prepend(checkbox);
        row.prepend(cell);
    });

    // Add event listener to "Select All" checkbox to toggle all checkboxes
    selectAllCheckbox.addEventListener("change", function () {
        const checkboxes = document.querySelectorAll(".select-checkbox");
        checkboxes.forEach(checkbox => {
            checkbox.checked = selectAllCheckbox.checked;
        });
    });

    // Add filter button below the table
    const filterButton = document.createElement("button");
    filterButton.id = "filter-selections";
    filterButton.textContent = "Filter Selections";
    filterButton.addEventListener("click", toggleFilterSelections);

    table.parentElement.appendChild(filterButton);
}

function toggleFilterSelections() {
    const checkboxes = document.querySelectorAll(".select-checkbox");
    const tableRows = document.querySelectorAll("#results-table tbody tr");
    const filterButton = document.getElementById("filter-selections");

    let anyRowHidden = hiddenRows.length > 0;

    if (anyRowHidden) {
        // Restore hidden rows and ensure checkboxes are restored
        hiddenRows.forEach(row => {
            row.style.display = '';  // Reset the display style to its default
            // Ensure the "Select" checkbox is added to each row
            const checkboxCell = row.querySelector("td:first-child");
            if (checkboxCell && !checkboxCell.querySelector("input[type='checkbox']")) {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.classList.add("select-checkbox");
                checkboxCell.prepend(checkbox);
            }
        });
        hiddenRows = [];  // Clear the hidden rows array

        // Re-add the checkboxes to all rows (in case they weren't added for visible rows)
        tableRows.forEach(row => {
            const checkboxCell = row.querySelector("td:first-child");
            if (checkboxCell && !checkboxCell.querySelector("input[type='checkbox']")) {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.classList.add("select-checkbox");
                checkboxCell.prepend(checkbox);
            }
        });

        // Add "Status" column header if it's not already there
        const thead = document.querySelector("#results-table thead");
        let statusHeader = thead.querySelector("th.status-header");
        if (!statusHeader) {
            // Create the "Status" header if not present
            statusHeader = document.createElement("th");
            statusHeader.textContent = "Status"; // Add the Status text
            statusHeader.classList.add("status-header"); // Add a class for identification

            // Find the last header cell
            const headerRow = thead.querySelector("tr");  // Assuming only one row for headers
            const lastHeaderCell = headerRow.lastElementChild;

            // Insert "Status" header before the last one
            headerRow.insertBefore(statusHeader, lastHeaderCell);
        }

        // Change the button text to "Filter Selections"
        filterButton.textContent = "Filter Selections";
    } else {
        // Filter selected rows (hide unselected ones)
        checkboxes.forEach((checkbox, index) => {
            const row = tableRows[index];
            if (!checkbox.checked) {
                row.style.display = 'none';  // Hide unselected rows
                hiddenRows.push(row);  // Add to hidden rows array
            }
        });

        // Change the button text to "Show All Rows"
        filterButton.textContent = "Show All Rows";
    }
}

// Run function after table is populated
document.addEventListener("DOMContentLoaded", addSelectColumn);
        
    </script>

    <!-- Add Tablesort JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tablesort/5.2.1/tablesort.min.js"></script>
    <!-- PapaParse for CSV Export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

<!-- jsPDF for PDF Export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<!-- Font Awesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
